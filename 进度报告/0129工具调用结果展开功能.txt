========================================
进度报告 - 工具调用结果展开功能
========================================
日期：2026-01-29
功能：为功能二的工具调用状态栏添加展开按钮，显示工具调用详细结果

========================================
一、需求背景
========================================

在功能二（咨询模块）中，AI会调用工具（如法规检索、智能审单）来获取信息。
当前实现：
- ✅ 工具调用状态已可显示（调用中/调用完毕）
- ✅ 工具状态嵌入在AI回答的流中间
- ❌ 工具调用返回的详细结果对用户不可见

用户需求：
在工具状态栏右侧添加一个V字形展开按钮，点击后可以查看工具返回的详细结果。

关键要求：
1. 展开按钮显示在工具状态栏右侧
2. 使用V字形图标（chevron-down）
3. 点击可展开/收起工具结果
4. 通过CSS类方式实现，确保后续添加任何新工具都能自动支持

========================================
二、技术实现方案
========================================

【核心思路】
后端传递工具结果 → 前端存储并显示 → 用户点击展开按钮查看详情

【实现架构】
```
后端（Python）
  └─ LangGraph astream_events
     └─ on_tool_end 事件
        └─ 获取 event["data"]["output"]
           └─ SSE 流式传输到前端
              └─ tool_end 事件（包含 tool_result 字段）

前端（JavaScript）
  └─ SSE 事件监听
     ├─ tool_start：创建展开按钮 + 结果容器
     ├─ tool_end：保存工具结果到 Map
     └─ 用户点击：toggleToolResult() 切换显示
```

========================================
三、后端实现
========================================

文件：src/services/chat_agent.py
位置：第199-208行

【修改前】
```python
elif event_type == "on_tool_end":
    t_name = event["name"]
    yield f"data: {json.dumps({'type': 'tool_end', 'tool_name': t_name, 'content': f'工具 [{t_name}] 调用完毕'}, ensure_ascii=False)}\n\n"
```

问题：没有传递工具执行结果

【修改后】
```python
elif event_type == "on_tool_end":
    t_name = event["name"]
    # 获取工具执行结果
    tool_output = event["data"].get("output", "")
    # 格式化工具结果（限制长度，避免过长）
    if isinstance(tool_output, str):
        tool_result = tool_output[:2000] + "..." if len(tool_output) > 2000 else tool_output
    else:
        tool_result = str(tool_output)[:2000]
    yield f"data: {json.dumps({'type': 'tool_end', 'tool_name': t_name, 'content': f'工具 [{t_name}] 调用完毕', 'tool_result': tool_result}, ensure_ascii=False)}\n\n"
```

关键改动：
1. 从 event["data"].get("output") 获取工具执行结果
2. 限制结果长度为2000字符（避免前端页面卡顿）
3. 在 JSON 响应中添加 'tool_result' 字段

【性能考虑】
- 限制长度：2000字符
- 超出显示：添加 "..." 省略号
- 类型处理：支持字符串和其他类型（自动转字符串）

========================================
四、前端CSS样式
========================================

文件：web/css/style.css
位置：第38-138行

【1. 工具状态栏布局调整】
```css
.chat-tool-status {
    display: flex;
    align-items: center;
    justify-content: space-between;  /* 新增：左右布局 */
}
```

新增左侧容器：
```css
.chat-tool-status-left {
    display: flex;
    align-items: center;
    gap: 8px;
}
```

DOM 结构变化：
```
修改前：
┌────────────────────────────────────┐
│ ⚙️ 法规检索  调用完毕              │
└────────────────────────────────────┘

修改后：
┌───────────────────────────┬────────┐
│ ⚙️ 法规检索  调用完毕      │  ▼     │
└───────────────────────────┴────────┘
  左侧容器（固定）           展开按钮
```

【2. 展开按钮样式】
```css
.chat-tool-expand-btn {
    background: none;
    border: none;
    color: #94a3b8;
    cursor: pointer;
    padding: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    font-size: 0.75rem;
}

.chat-tool-expand-btn:hover {
    color: #cbd5e1;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
}

.chat-tool-expand-btn.expanded {
    transform: rotate(180deg);  /* V字形旋转180度 */
}
```

交互效果：
- 默认：灰色 V 形
- 悬停：颜色变亮 + 背景高亮
- 点击：旋转180度变成 ∧ 形

【3. 结果容器样式】
```css
.chat-tool-result {
    max-height: 0;              /* 初始隐藏 */
    overflow: hidden;
    transition: max-height 0.3s ease-out;  /* 平滑展开 */
    margin-top: 0;
}

.chat-tool-result.show {
    max-height: 400px;          /* 展开时最大高度 */
    overflow-y: auto;           /* 超出可滚动 */
    margin-top: 8px;
}

.chat-tool-result-content {
    background-color: rgba(0, 0, 0, 0.2);  /* 深色背景 */
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 6px;
    padding: 10px 12px;
    font-size: 0.8rem;
    color: #cbd5e1;
    white-space: pre-wrap;      /* 保留换行 */
    word-break: break-word;     /* 长单词换行 */
    line-height: 1.5;
}
```

设计细节：
- 平滑动画：0.3s ease-out
- 最大高度：400px（避免占据过多屏幕空间）
- 超出滚动：overflow-y: auto
- 深色背景：不刺眼
- 保留格式：pre-wrap 保留工具结果的换行和空格

========================================
五、前端JS逻辑
========================================

文件：web/js/chat.js

【1. 全局变量】
位置：第17-19行

```javascript
// 工具结果存储（按工具索引）
const toolResults = new Map();
let toolIndex = 0;
```

设计思路：
- toolIndex：全局计数器，为每个工具分配唯一索引
- toolResults：Map 结构存储工具结果（key=工具索引，value=结果内容）

为什么使用 Map？
- 高效的键值对查找
- 支持任意类型的键
- 保持插入顺序

【2. 展开/收起函数】
位置：第21-37行

```javascript
function toggleToolResult(toolIdx) {
    const resultContainer = document.getElementById(`tool-result-${toolIdx}`);
    const expandBtn = document.getElementById(`tool-expand-${toolIdx}`);

    if (resultContainer && expandBtn) {
        const isExpanded = resultContainer.classList.contains('show');

        if (isExpanded) {
            resultContainer.classList.remove('show');
            expandBtn.classList.remove('expanded');
        } else {
            resultContainer.classList.add('show');
            expandBtn.classList.add('expanded');
        }
    }
}
```

交互逻辑：
1. 通过工具索引查找对应的DOM元素
2. 检查当前是否已展开（.show 类）
3. 切换 .show 和 .expanded 类

【3. tool_start 事件处理】
位置：第108-143行

```javascript
else if (data.type === 'tool_start') {
    // 工具调用开始 - 插入到AI回答气泡内（在文本内容之后）
    const currentToolIdx = toolIndex++;
    toolResults.set(currentToolIdx, ''); // 初始化结果为空

    const toolDisplayName = getToolDisplayName(data.tool_name);
    const toolHtml = `
        <div class="chat-tool-status calling" data-tool-name="${data.tool_name}" data-tool-idx="${currentToolIdx}">
            <div class="chat-tool-status-left">
                <i class="fa-solid fa-gear tool-icon"></i>
                <span class="tool-name">${toolDisplayName}</span>
                <span class="status-text">${t('tool_calling')}</span>
            </div>
            <button class="chat-tool-expand-btn" id="tool-expand-${currentToolIdx}" onclick="toggleToolResult(${currentToolIdx})" title="展开/收起工具结果">
                <i class="fa-solid fa-chevron-down"></i>
            </button>
        </div>
        <div class="chat-tool-result" id="tool-result-${currentToolIdx}">
            <div class="chat-tool-result-content" id="tool-result-content-${currentToolIdx}"></div>
        </div>
    `;

    // 插入到DOM
    const answerElement = document.getElementById(answerId);
    if (lastContentDiv) {
        lastContentDiv.insertAdjacentHTML('afterend', toolHtml);
    } else {
        answerElement.insertAdjacentHTML('beforeend', toolHtml);
    }

    // 重置内容buffer
    currentContentBuffer = '';
    lastContentDiv = null;
}
```

关键步骤：
1. 分配工具索引：`const currentToolIdx = toolIndex++`
2. 初始化空结果：`toolResults.set(currentToolIdx, '')`
3. 生成HTML：包含展开按钮和空结果容器
4. 插入DOM：在 lastContentDiv 之后
5. 重置buffer：准备接收工具调用后的新内容

【4. tool_end 事件处理】
位置：第144-179行

```javascript
else if (data.type === 'tool_end') {
    const answerElement = document.getElementById(answerId);
    const toolStatusElements = answerElement.querySelectorAll('.chat-tool-status.calling');

    if (toolStatusElements.length > 0) {
        const lastToolStatus = toolStatusElements[toolStatusElements.length - 1];
        const toolDisplayName = getToolDisplayName(data.tool_name);
        const toolIdx = lastToolStatus.getAttribute('data-tool-idx');

        // 保存工具结果
        if (data.tool_result && toolIdx !== null) {
            toolResults.set(parseInt(toolIdx), data.tool_result);
            // 更新结果容器内容
            const resultContent = document.getElementById(`tool-result-content-${toolIdx}`);
            if (resultContent) {
                resultContent.textContent = data.tool_result;
            }
        }

        // 更新工具状态为完成
        lastToolStatus.className = 'chat-tool-status done';
        lastToolStatus.innerHTML = `
            <div class="chat-tool-status-left">
                <i class="fa-solid fa-check tool-icon"></i>
                <span class="tool-name">${toolDisplayName}</span>
                <span class="status-text">${t('tool_call_done')}</span>
            </div>
            <button class="chat-tool-expand-btn" id="tool-expand-${toolIdx}" onclick="toggleToolResult(${toolIdx})" title="展开/收起工具结果">
                <i class="fa-solid fa-chevron-down"></i>
            </button>
        `;
    }
}
```

关键步骤：
1. 查找最后一个调用中的工具状态
2. 获取工具索引（从 data-tool-idx 属性）
3. 保存结果到 Map：`toolResults.set(toolIdx, data.tool_result)`
4. 更新结果容器内容：`resultContent.textContent = data.tool_result`
5. 重新渲染工具状态栏（更新为完成状态，保持展开按钮）

【5. 每次对话重置】
位置：第45-47行

```javascript
async function sendMessage() {
    // ...
    // 重置工具索引（每次新对话）
    toolIndex = 0;
    toolResults.clear();
    // ...
}
```

为什么需要重置？
- 避免不同对话间的工具索引冲突
- 释放内存（清空 Map）

========================================
六、DOM结构详解
========================================

【完整HTML结构】
```html
<div id="ai-xxx" class="chat-bubble chat-ai">
    <!-- 工具调用前的AI回答 -->
    <div class="ai-content">
        好的，我来帮您查询海关归类总规则...
    </div>

    <!-- 工具状态栏 -->
    <div class="chat-tool-status done" data-tool-name="search_customs_regulations" data-tool-idx="0">
        <!-- 左侧：图标 + 工具名 + 状态 -->
        <div class="chat-tool-status-left">
            <i class="fa-solid fa-check tool-icon"></i>
            <span class="tool-name">法规检索</span>
            <span class="status-text">调用完毕</span>
        </div>

        <!-- 右侧：展开按钮 -->
        <button class="chat-tool-expand-btn" id="tool-expand-0" onclick="toggleToolResult(0)">
            <i class="fa-solid fa-chevron-down"></i>
        </button>
    </div>

    <!-- 工具结果容器（默认隐藏） -->
    <div class="chat-tool-result" id="tool-result-0">
        <div class="chat-tool-result-content" id="tool-result-content-0">
            根据查询结果，《进出口税则商品及品目注释》规定...
        </div>
    </div>

    <!-- 工具调用后的AI回答 -->
    <div class="ai-content">
        根据查询结果，归类总规则是...
    </div>
</div>
```

【类名说明】
- `.chat-tool-status.calling` - 调用中（紫色边框，齿轮图标）
- `.chat-tool-status.done` - 调用完毕（绿色边框，对勾图标）
- `.chat-tool-result.show` - 展开显示（max-height: 400px）
- `.chat-tool-expand-btn.expanded` - 按钮旋转（transform: rotate(180deg)）

【ID命名规则】
- 工具状态：`chat-tool-status` + data 属性存储索引
- 展开按钮：`tool-expand-{索引}`
- 结果容器：`tool-result-{索引}`
- 结果内容：`tool-result-content-{索引}`

========================================
七、数据流详解
========================================

【完整流程】
```
1. 用户输入："帮我查询海关归类总规则"
   ↓
2. 前端：toolIndex = 0
   ↓
3. 后端：AI决定调用工具 search_customs_regulations
   ↓
4. 后端：发送 tool_start 事件
   SSE: {"type": "tool_start", "tool_name": "search_customs_regulations"}
   ↓
5. 前端：接收 tool_start
   - currentToolIdx = 0
   - toolIndex++ → toolIndex = 1
   - toolResults.set(0, '')
   - 创建HTML：tool-expand-0 + tool-result-0
   ↓
6. 后端：工具执行，返回结果
   - 假设结果为："根据《进出口税则》，归类总规则..."
   ↓
7. 后端：发送 tool_end 事件
   SSE: {
     "type": "tool_end",
     "tool_name": "search_customs_regulations",
     "tool_result": "根据《进出口税则》，归类总规则..."
   }
   ↓
8. 前端：接收 tool_end
   - toolResults.set(0, "根据《进出口税则》...")
   - document.getElementById('tool-result-content-0').textContent = "根据《进出口税则》..."
   - 更新工具状态为 done
   ↓
9. 用户：点击展开按钮
   ↓
10. 前端：toggleToolResult(0)
    - resultContainer.classList.add('show')
    - expandBtn.classList.add('expanded')
    ↓
11. CSS：.chat-tool-result.show 生效
    - max-height: 0 → 400px
    - 平滑过渡动画 0.3s
    ↓
12. 用户：看到工具结果展开显示
```

【多工具调用场景】
```
用户输入："帮我审核报关单，然后查询相关法规"

工具1：audit_declaration（索引0）
  ├─ tool_start → toolIndex = 0 → 创建 tool-expand-0
  ├─ tool_end → 保存结果到 toolResults.set(0, "...")
  └─ AI继续回答

工具2：search_customs_regulations（索引1）
  ├─ tool_start → toolIndex = 1 → 创建 tool-expand-1
  ├─ tool_end → 保存结果到 toolResults.set(1, "...")
  └─ AI继续回答

结果：
- toolResults = Map {0 => "审单结果...", 1 => "法规结果..."}
- 两个展开按钮互不干扰
```

========================================
八、通用性设计
========================================

【为什么后续添加新工具无需修改代码？】

核心原理：基于事件和CSS类，而非工具名称

1. **后端通用性**
   ```python
   elif event_type == "on_tool_end":
       t_name = event["name"]  # 任何工具名称
       tool_output = event["data"].get("output", "")
       # ... 处理逻辑与工具名称无关
   ```
   - 不依赖具体的工具名称
   - 所有工具都走同一个事件处理逻辑

2. **前端通用性**
   ```javascript
   if (data.type === 'tool_start') {
       const currentToolIdx = toolIndex++;  // 自动分配索引
       // ... 生成HTML（使用 data-tool-idx 属性）
   }
   ```
   - 不判断工具类型
   - 为每个工具自动分配索引
   - 使用 data 属性存储索引，便于后续查找

3. **CSS通用性**
   ```css
   .chat-tool-status { ... }  /* 所有工具状态栏 */
   .chat-tool-expand-btn { ... }  /* 所有展开按钮 */
   .chat-tool-result { ... }  /* 所有结果容器 */
   ```
   - 通过类名应用样式
   - 不依赖工具名称

【添加新工具的步骤】
假设要添加一个新工具 "calculate_tax"（税费计算）：

步骤1：在 chat_agent.py 中定义工具
```python
def calculate_tax(query: str) -> str:
    """计算税费"""
    # ... 实现逻辑
    return result
```

步骤2：注册到 Agent
```python
tools = [
    audit_declaration,
    search_customs_regulations,
    calculate_tax  # 新增
]
```

步骤3：添加国际化文本（可选）
```javascript
// web/js/i18n.js
'calculate_tax': '税费计算',
```

完成！无需修改：
- ✅ 后端事件处理逻辑
- ✅ 前端展开逻辑
- ✅ CSS样式

========================================
九、性能优化
========================================

【1. 结果长度限制】
后端：
```python
tool_result = tool_output[:2000] + "..." if len(tool_output) > 2000 else tool_output
```

原因：
- 避免传输大量数据（SSE 流式传输）
- 避免前端 DOM 渲染卡顿
- 2000字符足够展示关键信息

【2. 容器高度限制】
CSS：
```css
.chat-tool-result.show {
    max-height: 400px;
    overflow-y: auto;
}
```

原因：
- 避免单个工具结果占据过多屏幕空间
- 用户可以通过滚动查看完整内容
- 400px 适合大多数屏幕

【3. 内存管理】
JS：
```javascript
// 每次新对话重置
toolIndex = 0;
toolResults.clear();
```

原因：
- 避免长时间对话后 Map 无限增长
- 释放已关闭对话的工具结果
- 重新开始索引计数

【4. DOM 操作优化】
```javascript
// 使用 insertAdjacentHTML 而不是 innerHTML
lastContentDiv.insertAdjacentHTML('afterend', toolHtml);
```

原因：
- insertAdjacentHTML 不会破坏现有元素
- innerHTML 会重新创建整个容器，性能较差

========================================
十、测试验证
========================================

【测试场景1：法规检索工具】
输入："帮我查询海关归类总规则是什么？"

预期结果：
✅ 工具状态栏右侧显示V字形展开按钮
✅ 点击V字形，展开显示法规检索结果
✅ 再次点击，收起结果
✅ V字形图标旋转180度指示展开状态
✅ 结果内容正确显示（包括格式和换行）

实际结果：全部通过 ✅

【测试场景2：审单工具】
输入："帮我审核这段报关单数据"

预期结果：
✅ 工具状态栏右侧显示V字形展开按钮
✅ 点击后展开显示审单结果（风险分析详情）
✅ 结果过长时（>400px）容器内部滚动
✅ 多个规则结果都能正确显示

实际结果：全部通过 ✅

【测试场景3：多工具调用】
输入："帮我审核报关单并查询相关法规"

预期结果：
✅ 两个工具状态栏都显示展开按钮
✅ 点击第一个工具的按钮，只展开第一个结果
✅ 点击第二个工具的按钮，只展开第二个结果
✅ 两个展开操作互不干扰

实际结果：全部通过 ✅

【测试场景4：边界情况】
测试内容：
- 工具结果为空
- 工具结果超长（>2000字符）
- 工具结果包含特殊字符（换行、引号、HTML标签）

预期结果：
✅ 空结果：容器展开但内容为空
✅ 超长结果：显示前2000字符 + "..."
✅ 特殊字符：正确转义，不破坏DOM结构

实际结果：全部通过 ✅

========================================
十一、用户反馈优化
========================================

【视觉效果】
1. 图标旋转
   - 默认：▼（向下，表示可展开）
   - 展开：▲（向上，表示可收起）
   - 旋转动画：平滑过渡 0.2s

2. 颜色反馈
   - 默认：灰色 (#94a3b8)
   - 悬停：亮灰色 (#cbd5e1)
   - 展开：保持亮灰色

3. 背景高亮
   - 悬停时：浅色背景 rgba(255, 255, 255, 0.05)
   - 圆角：4px
   - 提示可点击

【交互体验】
1. 悬停提示
   ```html
   title="展开/收起工具结果"
   ```
   鼠标悬停在按钮上时显示提示文字

2. 平滑动画
   - 展开：0.3s ease-out
   - 收起：0.3s ease-out
   - 旋转：0.2s

3. 响应式设计
   - 按钮大小：自适应
   - 最大高度：400px（适合移动端和桌面端）
   - 滚动条：自动显示/隐藏

========================================
十二、总结
========================================

【实现成果】
✅ 工具调用结果展开功能已成功实现
✅ 通过CSS类方式确保通用性，后续新增工具自动支持
✅ 用户体验流畅，动画效果平滑
✅ 工具结果限制长度（2000字符），避免页面卡顿
✅ 所有测试场景通过

【修改文件清单】
1. src/services/chat_agent.py（后端：传递工具结果）
2. web/css/style.css（样式：展开按钮和结果容器）
3. web/js/chat.js（前端：展开逻辑和结果存储）

【代码统计】
- 后端修改：~10行
- CSS新增：~60行
- JS新增/修改：~80行
- 总计：~150行

【技术亮点】
1. **工具索引机制**
   - 全局计数器 toolIndex
   - Map 存储结果
   - 确保多个工具调用互不干扰

2. **通用性设计**
   - 基于事件和CSS类
   - 不依赖具体工具名称
   - 后续添加新工具无需修改代码

3. **性能优化**
   - 限制结果长度（2000字符）
   - 限制容器高度（400px）
   - 每次对话重置 Map 和索引

4. **用户体验**
   - 平滑动画（0.3s ease-out）
   - 图标旋转指示状态
   - 悬停视觉反馈
   - 深色背景不刺眼

【后续优化建议】
1. 添加工具结果复制按钮
2. 支持工具结果导出（JSON/TXT）
3. 添加工具调用耗时统计
4. 支持工具结果高亮搜索关键词
5. 添加工具结果折叠记忆功能（记住用户的展开/收起状态）

========================================
测试完成
========================================
端口清理：PID 56340（端口 8000）
测试时间：2026-01-29
测试人员：Claude Code
