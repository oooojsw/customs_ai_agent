import base64
import json
import requests
from typing import Tuple, Optional, Dict
from openai import AzureOpenAI
from fastapi import UploadFile

from src.config.loader import settings

# 自定义异常
class NotDeclarationError(ValueError):
    """当图片内容不是报关单时抛出"""
    pass

class ImageTextExtractor:
    def __init__(self, image_config: Dict = None):
        """
        初始化图片识别器

        Args:
            image_config: 图像模型配置字典，如果为 None 则从数据库加载
        """
        self._config = image_config or self._load_config()

        # 从配置中获取参数
        self._provider = self._config.get('provider', 'gemini')
        self._api_key = self._config.get('api_key', '')
        self._model = self._config.get('model', settings.MODEL_NAME)
        self._temperature = self._config.get('temperature', 0.1)
        self._max_tokens = self._config.get('max_tokens', 16384)
        self._endpoint = self._config.get('endpoint')
        self._api_version = self._config.get('api_version', settings.AZURE_OAI_VERSION)

        # 初始化 Azure OpenAI 客户端（如果是 Azure provider）
        self._azure_client = None
        if self._provider == "azure" and all([self._api_key, self._endpoint]):
            try:
                self._azure_client = AzureOpenAI(
                    api_key=self._api_key,
                    api_version=self._api_version,
                    azure_endpoint=self._endpoint
                )
            except Exception as e:
                print(f"[Warning] Azure OpenAI 客户端初始化失败: {e}")

    @staticmethod
    def _load_config() -> Dict:
        """加载图像模型配置（静态方法，用于初始化）"""
        try:
            # 优先从 image_config_loader 加载用户配置
            from src.config.image_loader import image_config_loader
            config = image_config_loader.get_config()

            # 如果用户配置已启用，使用用户配置
            if config.get('is_enabled', False):
                print(f"[ImageExtractor] 使用用户配置: {config['provider']}/{config['model_name']}")
                return {
                    'provider': config['provider'],
                    'api_key': config['api_key'],
                    'base_url': config.get('base_url'),
                    'model': config['model_name'],
                    'temperature': config.get('temperature', 0.1),
                    'max_tokens': config.get('max_tokens', 16384),
                    'endpoint': config.get('endpoint'),
                    'api_version': config.get('api_version'),
                    'source': 'database'
                }
            else:
                # 使用 .env 默认配置
                print(f"[ImageExtractor] 使用 .env 配置: gemini")
                return {
                    'provider': 'gemini',
                    'api_key': settings.GOOGLE_API_KEY,
                    'base_url': None,
                    'model': settings.MODEL_NAME,
                    'temperature': 0.1,
                    'max_tokens': 16384,
                    'endpoint': settings.AZURE_OAI_ENDPOINT,
                    'api_version': settings.AZURE_OAI_VERSION,
                    'source': 'env'
                }
        except Exception as e:
            print(f"[Error] 配置加载失败: {e}")
            return {
                'provider': 'gemini',
                'api_key': '',
                'model': 'gemini-2.0-flash',
                'temperature': 0.1,
                'max_tokens': 16384
            }

    @classmethod
    async def create_async(cls, db=None):
        """
        异步工厂方法：从数据库加载配置创建实例

        Args:
            db: 数据库会话，如果为 None 则使用 .env 配置

        Returns:
            ImageTextExtractor 实例
        """
        if db:
            try:
                from src.config.image_loader import image_config_loader
                config = await image_config_loader.load_config(db)
                return cls(image_config=config)
            except Exception as e:
                print(f"[Warning] 从数据库加载图像配置失败: {e}，使用 .env 配置")

        # 回退到静态配置
        return cls()

    def extract_text(self, image_bytes: bytes, mime_type: str, language: str = "zh") -> Tuple[str, str]:
        """
        核心函数：从图片中提取报关单字段
        1. 校验图片是否为报关单
        2. 尝试用 Gemini 提取
        3. 如果 Gemini 失败，自动切换到 Azure OpenAI
        """
        print(f"[DEBUG] 开始图片识别，语言设置: {language}, 图片类型: {mime_type}, 大小: {len(image_bytes)} bytes")

        # 1. 内容校验
        try:
            is_declaration, reason = self._validate_image_content(image_bytes, mime_type, language)
            if not is_declaration:
                raise NotDeclarationError(f"图片似乎不是报关单，因为：{reason}")
        except Exception as e:
            print(f"[ERROR] 图片内容校验失败: {type(e).__name__}: {e}")
            # 如果校验失败（网络问题等），继续尝试识别，不要直接中断
            print("[WARN] 跳过校验，直接尝试识别...")

        # 2. 主模型 (Gemini)
        try:
            print("INFO: 正在尝试使用 Gemini-Flash 模型进行图片识别...")
            text = self._call_gemini_vision(image_bytes, mime_type, language)
            # 格式化检查与修正
            text = self._ensure_multi_item_format(text, language)
            print("INFO: Gemini-Flash 识别成功。")
            return text, self._gemini_model
        except Exception as e:
            error_type = type(e).__name__
            error_msg = str(e)
            print(f"[Warning] Gemini-Flash 识别失败: {error_type}: {error_msg}")
            import traceback
            print(f"[DEBUG] Gemini 详细错误堆栈:\n{traceback.format_exc()}")

            # 3. 备用模型 (Azure OpenAI)
            if self._azure_client:
                print("INFO: 已切换到 Azure OpenAI 模型进行重试...")
                try:
                    text = self._call_azure_openai_vision(image_bytes, mime_type, language)
                    # 格式化检查与修正 (用 Gemini-Text)
                    text = self._ensure_multi_item_format(text, language)
                    print("INFO: Azure OpenAI 识别成功。")
                    return text, self._azure_deployment
                except Exception as az_e:
                    az_error_type = type(az_e).__name__
                    az_error_msg = str(az_e)
                    print(f"[Error] Azure OpenAI 备用模型也识别失败: {az_error_type}: {az_error_msg}")
                    print(f"[DEBUG] Azure 详细错误堆栈:\n{traceback.format_exc()}")
                    raise RuntimeError(
                        f"主模型和备用模型均无法处理该图片\n"
                        f"Gemini错误: {error_type}: {error_msg}\n"
                        f"Azure错误: {az_error_type}: {az_error_msg}"
                    ) from az_e
            else:
                print("[Error] 未配置 Azure OpenAI 备用模型，无法重试。")
                raise RuntimeError(
                    f"Gemini 图片识别失败，且未配置备用模型\n"
                    f"错误详情: {error_type}: {error_msg}"
                ) from e


    def _validate_image_content(self, image_bytes: bytes, mime_type: str, language: str = "zh") -> Tuple[bool, str]:
        """
        使用 Gemini 的快速能力判断图片内容是否为报关单
        """
        language_instruction = self._get_language_instruction(language)

        # 根据语言设置校验提示词
        if language == "vi":
            prompt = f'{language_instruction}\nHình ảnh này có phải là tờ khai hải quan không? Vui lòng trả lời "Có" hoặc "Không". Nếu là "Không", hãy giải thích ngắn gọn bằng tiếng Việt nội dung hình ảnh là gì (ví dụ: Đây là ảnh phong cảnh).'
        else:
            prompt = f'{language_instruction}\n这张图片是海关货物报关单吗？请直接回答"是"或"否"。如果是"否"，请用一句话简单说明图片内容（例如：这是一张风景照）。'

        try:
            # 直接调用原始 Gemini 接口，使用配置中的API Key
            api_url = (
                f"https://generativelanguage.googleapis.com/v1beta/models/"
                f"{self._gemini_model}:generateContent?key={self._api_key}"
            )
            image_b64 = base64.b64encode(image_bytes).decode("ascii")
            payload = {
                "contents": [{"parts": [
                    {"text": prompt},
                    {"inline_data": {"mime_type": mime_type, "data": image_b64}}
                ]}],
                "generationConfig": {"temperature": 0.0, "maxOutputTokens": 50}
            }
            response = requests.post(api_url, json=payload, timeout=30, verify=False)
            response.raise_for_status()
            data = response.json()
            result_text = data["candidates"][0]["content"]["parts"][0]["text"].strip()

            # 根据语言设置解析响应
            if language == "vi":
                # 越南语：Có / Không
                if result_text.startswith("Có") or result_text.startswith("có"):
                    return True, "Là tờ khai hải quan"
                else:
                    # 提取"Không"之后的理由
                    reason = result_text.replace("Không", "").replace("không", "").strip("，。,. ")
                    return False, reason if reason else "Nội dung không phù hợp"
            else:
                # 中文：是 / 否
                if result_text.startswith("是"):
                    return True, "是报关单"
                else:
                    # 提取"否"之后的理由
                    reason = result_text.replace("否", "").strip("，。,. ")
                    return False, reason if reason else "内容不符"
        except Exception as e:
            print(f"[Warning] 警告: 图片内容校验步骤失败: {e}。为保证流程继续，暂时跳过校验。")
            # 在校验失败时默认通过，以避免网络问题导致整个流程中断
            return True, "校验异常，已跳过"

    def _call_azure_openai_vision(self, image_bytes: bytes, mime_type: str, language: str = "zh") -> str:
        """调用 Azure OpenAI GPT-4o 模型进行图片识别"""
        if not self._azure_client:
            raise RuntimeError("Azure OpenAI 客户端未初始化")

        image_b64 = base64.b64encode(image_bytes).decode('ascii')
        image_url = f"data:{mime_type};base64,{image_b64}"

        prompt = self._build_prompt(language)  # 传入 language 参数

        response = self._azure_client.chat.completions.create(
            model=self._azure_deployment,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": image_url}}
                    ],
                }
            ],
            max_tokens=8192,  # 从 2048 提高到 8192 以支持越南语输出
            temperature=0.1
        )
        return response.choices[0].message.content.strip()

    def _build_prompt(self, language: str = "zh") -> str:
        language_instruction = self._get_language_instruction(language)

        # 根据语言设置字段名
        if language == "vi":
            return (
                f"{language_instruction}\n\n"
                "Bạn là trợ lý OCR tờ khai hải quan. Chỉ xuất văn bản thuần túy, KHÔNG Markdown.\n"
                "Trích xuất thông tin từ hình ảnh và xuất TOÀN BỘ bằng tiếng Việt.\n"
                "Nếu thông tin trống, ghi: để trống.\n\n"
                "Định dạng xuất:\n"
                "Số tờ khai:...\n"
                "Danh mục hàng hóa:\n"
                "- Hàng hóa 1:\n"
                "  Tên hàng hóa:...\n"
                "  Mã HS:... (giữ giải thích tiếng Trung nếu có)\n"
                "  Số lượng:... (kèm đơn vị)\n"
                "  Đơn giá:... (kèm tiền tệ)\n"
                "  Tổng giá:... (kèm tiền tệ)\n"
                "  Yếu tố khai báo:... (cách bằng dấu chấm phẩy)\n"
                "- Hàng hóa 2:\n"
                "  Tên hàng hóa:...\n"
                "  Mã HS:...\n"
                "  Số lượng:...\n"
                "  Đơn giá:...\n"
                "  Tổng giá:...\n"
                "  Yếu tố khai báo:...\n"
                "【Chứng từ đính kèm】\n"
                "Tổng trị giá hóa đơn:... (kèm tiền tệ)\n\n"
                "Quy tắc:\n"
                "1) Luôn dùng định dạng \"Danh mục hàng hóa/Hàng hóa 1\" ngay cả khi chỉ có 1 hàng.\n"
                "2) Đánh số theo thứ tự xuất hiện.\n"
                "3) Không gộp trường của các hàng khác nhau.\n"
                "4) Không đoán, thiếu thì ghi \"không xác định\".\n"
                "5) Kết quả phải hoàn toàn bằng tiếng Việt."
            )
        else:
            return (
                f"{language_instruction}\n\n"
                "你是报关单OCR与结构化助手。只输出纯文本，不要Markdown。\n"
                "从图片中提取报关单关键信息，全部用简体中文输出。\n"
                "如果某些信息为空，请标明为：为空。\n\n"
                "严格按以下格式输出：\n"
                "报关单号：...\n"
                "商品清单：\n"
                "- 商品1：\n"
                "  货物名称：...\n"
                "  HS编码：... (如果有中文释义请保留)\n"
                "  数量：... (含单位)\n"
                "  单价：... (含币种)\n"
                "  总价：... (含币种)\n"
                "  申报要素：... (用分号分隔)\n"
                "- 商品2：\n"
                "  货物名称：...\n"
                "  HS编码：...\n"
                "  数量：...\n"
                "  单价：...\n"
                "  总价：...\n"
                "  申报要素：...\n"
                "【随附单证】\n"
                "发票总额：... (含币种)\n\n"
                "规则：\n"
                "1) 若只有一个商品，也必须使用\"商品清单/商品1\"格式。\n"
                "2) 多个商品时按图片出现顺序编号。\n"
                "3) 不要合并不同商品的字段。\n"
                "4) 不要猜测，缺失字段写\"未知\"。\n"
                "5) 所有输出必须使用简体中文。"
            )

    def _build_reformat_prompt(self, raw_text: str, language: str = "zh") -> str:
        language_instruction = self._get_language_instruction(language)

        if language == "vi":
            return (
                f"{language_instruction}\n\n"
                "Sắp xếp nội dung tờ khai sau thành định dạng cố định. Chỉ xuất văn bản thuần túy, KHÔNG Markdown.\n"
                "Toàn bộ kết quả phải bằng tiếng Việt.\n\n"
                "Định dạng:\n"
                "Số tờ khai:...\n"
                "Danh mục hàng hóa:\n"
                "- Hàng hóa 1:\n"
                "  Tên hàng hóa:...\n"
                "  Mã HS:... (giữ giải thích tiếng Trung nếu có)\n"
                "  Số lượng:... (kèm đơn vị)\n"
                "  Đơn giá:... (kèm tiền tệ)\n"
                "  Tổng giá:... (kèm tiền tệ)\n"
                "  Yếu tố khai báo:... (cách bằng dấu chấm phẩy)\n"
                "- Hàng hóa 2:...\n"
                "【Chứng từ đính kèm】\n"
                "Tổng trị giá hóa đơn:... (kèm tiền tệ)\n\n"
                "Quy tắc:\n"
                "1) Luôn dùng \"Danh mục hàng hóa/Hàng hóa 1\" ngay cả khi chỉ có 1 hàng.\n"
                "2) Đánh số theo thứ tự xuất hiện.\n"
                "3) Không gộp trường.\n"
                "4) Không đoán, thiếu thì ghi \"không xác định\".\n"
                "5) Kết quả phải hoàn toàn bằng tiếng Việt.\n\n"
                f"Nội dung gốc:\n{raw_text}"
            )
        else:
            return (
                f"{language_instruction}\n\n"
                "将下面的报关单内容整理成固定格式。只输出纯文本，不要Markdown。所有输出必须使用简体中文。\n\n"
                "格式：\n"
                "报关单号：...\n"
                "商品清单：\n"
                "- 商品1：\n"
                "  货物名称：...\n"
                "  HS编码：... (如果有中文释义请保留)\n"
                "  数量：... (含单位)\n"
                "  单价：... (含币种)\n"
                "  总价：... (含币种)\n"
                "  申报要素：... (用分号分隔)\n"
                "- 商品2：...\n"
                "【随附单证】\n"
                "发票总额：... (含币种)\n\n"
                "规则：\n"
                "1) 若只有一个商品，也必须使用\"商品清单/商品1\"格式。\n"
                "2) 多个商品按出现顺序编号。\n"
                "3) 不要合并不同商品的字段。\n"
                "4) 不要猜测，缺失字段写\"未知\"。\n"
                "5) 所有输出必须使用简体中文。\n\n"
                f"原始内容：\n{raw_text}"
            )

    def _ensure_multi_item_format(self, text: str, language: str = "zh") -> str:
        # 检查是否符合格式（中文或越南语）
        format_markers = ["商品清单", "商品1", "Danh mục hàng hóa", "Hàng hóa 1"]
        if any(marker in text for marker in format_markers):
            return text
        print("INFO: 识别结果格式不完全符合要求，正在尝试自动修正...")
        prompt = self._build_reformat_prompt(text, language)
        # 统一使用 Gemini-Text 进行修正，成本低、速度快
        return self._call_gemini_text(prompt, language)

    def _call_gemini_vision(self, image_bytes: bytes, mime_type: str, language: str = "zh") -> str:
        """调用 Gemini Vision API"""
        api_url = (
            f"https://generativelanguage.googleapis.com/v1beta/models/"
            f"{self._model}:generateContent?key={self._api_key}"
        )
        prompt = self._build_prompt(language)
        image_b64 = base64.b64encode(image_bytes).decode("ascii")

        payload = {
            "contents": [{
                "parts": [
                    {"text": prompt},
                    {"inline_data": {"mime_type": mime_type, "data": image_b64}}
                ]
            }],
            "generationConfig": {
                "temperature": self._temperature,
                "maxOutputTokens": self._max_tokens
            }
        }

        response = requests.post(api_url, json=payload, timeout=60, verify=False)
        response.raise_for_status()
        data = response.json()
        try:
            return data["candidates"][0]["content"]["parts"][0]["text"].strip()
        except (KeyError, IndexError) as e:
            raise RuntimeError(f"Gemini 响应格式解析错误: {json.dumps(data)}") from e

    def _call_gemini_text(self, prompt: str, language: str = "zh") -> str:
        """调用 Gemini Text API"""
        api_url = (
            f"https://generativelanguage.googleapis.com/v1beta/models/"
            f"{self._model}:generateContent?key={self._api_key}"
        )
        payload = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {
                "temperature": self._temperature,
                "maxOutputTokens": self._max_tokens
            }
        }
        response = requests.post(api_url, json=payload, timeout=60, verify=False)
        response.raise_for_status()
        data = response.json()
        try:
            return data["candidates"][0]["content"]["parts"][0]["text"].strip()
        except (KeyError, IndexError) as e:
            raise RuntimeError(f"Gemini 文本响应解析错误: {json.dumps(data)}") from e

    def _get_language_instruction(self, language: str) -> str:
        """生成语言输出指令"""
        language_names = {
            "zh": "简体中文",
            "vi": "Tiếng Việt"
        }
        language_name = language_names.get(language, language_names["zh"])

        if language == "vi":
            return f"[NGÔN NGỮ: PHẢI xuất kết quả bằng TIẾNG VIỆT. Không dùng tiếng Trung/Anh. Dịch mọi nội dung sang tiếng Việt.]"
        else:
            return f"[语言：必须使用简体中文输出。禁止使用越南语/英语等其他语言。将所有内容翻译成中文。]"